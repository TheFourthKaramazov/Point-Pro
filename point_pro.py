import depth_pro
import numpy as np
import torch
import matplotlib.pyplot as plt
import open3d as o3d
import os
import cv2
from PIL import Image

def setup_device():
    if torch.cuda.is_available():
        device = torch.device("cuda")
        print("GPU is available and will be used")
    else:
        device = torch.device("cpu")
        print("GPU is not available, using CPU")
    return device

def get_image_paths_from_directory(directory, extensions=(".jpg", ".jpeg", ".png")):
    """Fetch all image file paths from the given directory."""
    return [os.path.join(directory, f) for f in os.listdir(directory) if f.lower().endswith(extensions)]

def load_and_process_images_from_directory(directory, transform, device):
    """Load and preprocess all images from a directory."""
    image_paths = get_image_paths_from_directory(directory)
    
    images_tensors = []
    focal_lengths = []
    
    for image_path in image_paths:
        image, _, f_px = depth_pro.load_rgb(image_path)
        images_tensors.append(transform(image).to(device))
        focal_lengths.append(f_px)
    
    return image_paths, images_tensors, focal_lengths

def run_depth_inference(model, image_tensors, focal_lengths):
    """Run depth inference on multiple images."""
    depth_maps = []
    focal_px_values = []
    
    with torch.no_grad():
        for image_tensor, f_px in zip(image_tensors, focal_lengths):
            prediction = model.infer(image_tensor, f_px=f_px)
            depth_maps.append(prediction["depth"].cpu().numpy())
            focal_px_values.append(prediction["focallength_px"].item())
    
    return depth_maps, focal_px_values

def create_point_clouds(depth_maps, images, focal_px_values, scale_ratio=1.0):
    """Create multiple point clouds from depth maps and images."""
    point_clouds = []
    
    for depth_map, image, focal_px in zip(depth_maps, images, focal_px_values):
        H, W = depth_map.shape
        image = ensure_image_format(image)
        
        x_grid, y_grid = np.meshgrid(np.arange(W), np.arange(H))
        cx, cy = W / 2, H / 2

        Z = depth_map * scale_ratio
        X = (x_grid - cx) * Z / focal_px
        Y = (y_grid - cy) * Z / focal_px

        point_map = np.stack((X, Y, Z), axis=-1)

        point_cloud = o3d.geometry.PointCloud()
        point_cloud.points = o3d.utility.Vector3dVector(point_map.reshape(-1, 3))
        point_cloud.colors = o3d.utility.Vector3dVector(image.reshape(-1, 3))

        valid_points = Z.flatten() > 0
        point_cloud.points = o3d.utility.Vector3dVector(np.asarray(point_cloud.points)[valid_points])
        point_cloud.colors = o3d.utility.Vector3dVector(np.asarray(point_cloud.colors)[valid_points])

        point_clouds.append(point_cloud)
    
    return point_clouds

def ensure_image_format(image):
    """Ensure image is in the correct format (H, W, 3) and properly scaled."""
    if isinstance(image, torch.Tensor):
        image = image.cpu().detach().numpy()
    
    if image.shape[0] == 3:  # If in (3, H, W) format
        image = np.transpose(image, (1, 2, 0))
    
    if image.min() < 0 or image.max() > 1:
        image = (image + 1) / 2  # Normalize to [0,1]
    
    return np.clip(image, 0, 1)

def visualize_results(images, depth_maps):
    """Visualize multiple images and depth maps."""
    num_images = len(images)
    fig, axes = plt.subplots(num_images, 2, figsize=(10, 5 * num_images))
    
    if num_images == 1:
        axes = [axes]  # Make it iterable for a single image
    
    for i, (image, depth_map) in enumerate(zip(images, depth_maps)):
        axes[i][0].imshow(image)
        axes[i][0].set_title(f"Original Image {i+1}")
        axes[i][0].axis('off')

        depth_plot = axes[i][1].imshow(depth_map, cmap='viridis')
        axes[i][1].set_title(f"Depth Map {i+1}")
        fig.colorbar(depth_plot, ax=axes[i][1], label='Depth (m)')
        axes[i][1].axis('off')

    plt.tight_layout()
    plt.show()

def save_point_clouds(point_clouds, image_paths):
    """Save multiple point clouds to 'generated_pointclouds/'."""
    output_dir = "generated_pointclouds"
    os.makedirs(output_dir, exist_ok=True)  # Ensure directory exists

    for point_cloud, image_path in zip(point_clouds, image_paths):
        filename = os.path.basename(image_path).split('.')[0] + ".ply"
        output_path = os.path.join(output_dir, filename)
        o3d.io.write_point_cloud(output_path, point_cloud)
        print(f"Saved: {output_path}")

def calculate_distances(depth_maps, points_of_interest=None):
    """
    Calculate absolute metric distances from the camera to objects in multiple depth maps.
    
    Parameters:
    depth_maps (list of np.array): List of depth maps generated by Depth Pro.
    points_of_interest (list of lists): Optional. List of lists, where each sublist contains
                                        (y, x) coordinates of specific points to measure.

    Returns:
    dict: A dictionary containing distance statistics or point-specific distances for each depth map.
    """
    results = {}
    
    for i, depth_map in enumerate(depth_maps):
        if points_of_interest is None:
            valid_depths = depth_map[depth_map > 0]  # Ignore zero or negative depths
            results[f'image_{i+1}'] = {
                'min_distance': np.min(valid_depths),
                'max_distance': np.max(valid_depths),
                'mean_distance': np.mean(valid_depths)
            }
        else:
            distances = {}
            for j, (y, x) in enumerate(points_of_interest[i]):
                distance = depth_map[y, x]
                distances[f'point_{j}'] = distance if distance > 0 else None
            results[f'image_{i+1}'] = distances
    
    return results
