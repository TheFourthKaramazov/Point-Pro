import depth_pro
import numpy as np
import torch
import matplotlib.pyplot as plt
import open3d as o3d
import cv2
from PIL import Image

def setup_device():
    if torch.cuda.is_available():
        device = torch.device("cuda")
        print("GPU is available and will be used")
    else:
        device = torch.device("cpu")
        print("GPU is not available, using CPU")
    return device

def load_and_process_image(image_path, transform, device):
    """Load and preprocess an image."""
    image, _, f_px = depth_pro.load_rgb(image_path)
    image_tensor = transform(image).to(device)
    return image_tensor, f_px

def run_depth_inference(model, image_tensor, f_px):
    """Run depth inference on the image using Depth Pro."""
    with torch.no_grad():
        prediction = model.infer(image_tensor, f_px=f_px)
    depth_map = prediction["depth"].cpu().numpy()
    focallength_px = prediction["focallength_px"].item()
    return depth_map, focallength_px

def create_point_cloud(depth_map, image, focallength_px, scale_ratio=1.0):
    """Create point cloud from depth map and image."""
    H, W = depth_map.shape
    image = ensure_image_format(image)
    
    x_grid, y_grid = np.meshgrid(np.arange(W), np.arange(H))
    cx, cy = W / 2, H / 2

    Z = depth_map * scale_ratio
    X = (x_grid - cx) * Z / focallength_px
    Y = (y_grid - cy) * Z / focallength_px

    point_map = np.stack((X, Y, Z), axis=-1)

    point_cloud = o3d.geometry.PointCloud()
    point_cloud.points = o3d.utility.Vector3dVector(point_map.reshape(-1, 3))
    point_cloud.colors = o3d.utility.Vector3dVector(image.reshape(-1, 3))

    valid_points = Z.flatten() > 0
    point_cloud.points = o3d.utility.Vector3dVector(np.asarray(point_cloud.points)[valid_points])
    point_cloud.colors = o3d.utility.Vector3dVector(np.asarray(point_cloud.colors)[valid_points])

    return point_cloud

def ensure_image_format(image):
    """Ensure image is in the correct format (H, W, 3) and properly scaled for point cloud processing and display."""
    if isinstance(image, torch.Tensor):
        image = image.cpu().detach().numpy()
    
    if image.shape[0] == 3:  # If it's in (3, H, W) format
        image = np.transpose(image, (1, 2, 0))
    
    # Check if the image is in [-1, 1] range
    if image.min() < 0 or image.max() > 1:
        # Rescale from [-1, 1] to [0, 1]
        image = (image + 1) / 2
    
    # Ensure the image is in [0, 1] range
    image = np.clip(image, 0, 1)
    
    return image

def visualize_results(image, depth_map):
    """Visualize the original image and depth map."""
    plt.figure(figsize=(10, 5))
    
    plt.subplot(1, 2, 1)
    plt.imshow(image)
    plt.title("Original Image")
    plt.axis('off')

    plt.subplot(1, 2, 2)
    depth_plot = plt.imshow(depth_map, cmap='viridis')
    plt.title("Depth Map")
    plt.colorbar(depth_plot, label='Depth (m)')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

def save_point_cloud(point_cloud, output_path):
    """Save the point cloud to a file."""
    o3d.io.write_point_cloud(output_path, point_cloud)

def calculate_distances(depth_map, points_of_interest=None):
    """
    Calculate absolute metric distances from the camera to objects in the depth map.
    
    Parameters:
    depth_map (np.array): The depth map generated by Depth Pro, assumed to be in meters.
    points_of_interest (list of tuples): Optional. List of (y, x) coordinates of specific points to measure.
                                         If None, calculates for all points.
    
    Returns:
    dict: A dictionary of distances. If points_of_interest is provided, keys are the points.
          If not, returns 'min', 'max', and 'mean' distances.
    """
    if points_of_interest is None:
        # Calculate statistics for the entire depth map
        valid_depths = depth_map[depth_map > 0]  # Ignore zero or negative depths
        return {
            'min_distance': np.min(valid_depths),
            'max_distance': np.max(valid_depths),
            'mean_distance': np.mean(valid_depths)
        }
    else:
        # Calculate distances for specific points
        distances = {}
        for i, (y, x) in enumerate(points_of_interest):
            distance = depth_map[y, x]
            if distance > 0:
                distances[f'point_{i}'] = distance
            else:
                distances[f'point_{i}'] = None  # or some invalid marker
        return distances

